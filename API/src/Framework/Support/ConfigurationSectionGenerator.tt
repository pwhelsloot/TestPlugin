<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#

// This template generates configuration section support classes using an XML
// file and conventions. To use this, copy the tt file into the project, give it
// an appropriate name, and next to it, add an XML file with the same name.

var section = new Section(XDocument.Load(Host.ResolvePath(Path.GetFileNameWithoutExtension(Host.TemplateFile) + ".xml")).Root);

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable CS1591

using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace <#= section.Namespace #>
{
<# foreach (var element in section.GetAllElements()) { #>
<# if (element is Element && ((Element)element).IsCollection) { #>
  public class <#= element.TypeName #>Collection : ConfigurationElementCollection
  {
    protected override ConfigurationElement CreateNewElement()
    {
      return new <#= element.TypeName #>();
    }

    protected override object GetElementKey(ConfigurationElement element)
    {
      return ((<#= element.TypeName #>)element).<#= ((Element)element).GetKeyPropertyName() #>;
    }
  }

<# } #>
<# if (section.IsGenerateInterfaces) { #>
  public interface <#= element.InterfaceName #>
  {
<# foreach (var attribute in element.Children.OfType<Attribute>()) { #>
    <#= attribute.Type #> <#= attribute.Name #> { get; }

<# } #>
<# foreach (var child in element.Children.OfType<Element>()) { #>
<# if (child.IsCollection) { #>
    IEnumerable<<#= child.InterfaceName #>> Get<#= UpperCaseFirst(child.ElementName) #>();
<# } else { #>
    <#= child.InterfaceName #> <#= UpperCaseFirst(child.ElementName) #> { get; }
<# } #>
<# } #>
  }

<# } #>
  public class <#= element.TypeName #> : <#= element is Section ? "ConfigurationSection" : "ConfigurationElement" #><# if (section.IsGenerateInterfaces) { #>, <#= element.InterfaceName #><# } #>

  {
<# foreach (var attribute in element.Children.OfType<Attribute>()) { #>
    [ConfigurationProperty("<#= attribute.ElementName #>"<# if (attribute.IsKey) { #>, IsKey = true<# } #><# if (attribute.IsRequired) { #>, IsRequired = true<# } #>)]
    public <#= attribute.Type #> <#= attribute.Name #>
    {
      get => (<#= attribute.Type #>)this["<#= attribute.ElementName #>"];
      set => this["<#= attribute.ElementName #>"] = value;
    }

<# } #>
<# foreach (var child in element.Children.OfType<Element>()) { #>
<# if (child.IsDefaultCollection) { #>
    [ConfigurationProperty("", Options = ConfigurationPropertyOptions.IsDefaultCollection)]
<# } else { #>
    [ConfigurationProperty("<#= child.ElementName #>"<# if (child.IsRequired) { #>, IsRequired = true<# } #>)]
<# } #>
    public <#= child.TypeName #><# if (child.IsCollection) { #>Collection<# } #> <#= UpperCaseFirst(child.ElementName) #>
    {
      get => (<#= child.TypeName #><# if (child.IsCollection) { #>Collection<# } #>)this[<# if (child.IsDefaultCollection) { #>string.Empty<# } else { #>"<#= child.ElementName #>"<# } #>];
      set => this[<# if (child.IsDefaultCollection) { #>string.Empty<# } else { #>"<#= child.ElementName #>"<# } #>] = value;
    }

<# if (section.IsGenerateInterfaces) { #>
<# if (child.IsCollection) { #>
    IEnumerable<<#= child.InterfaceName #>> <#= element.InterfaceName #>.Get<#= UpperCaseFirst(child.ElementName) #>()
    {
      return <#= UpperCaseFirst(child.ElementName) #>?.Cast<<#= child.TypeName #>>() ?? Enumerable.Empty<<#= child.TypeName #>>();
    }
<# } else { #>
    <#= child.InterfaceName #> <#= element.InterfaceName #>.<#= UpperCaseFirst(child.ElementName) #> => <#= UpperCaseFirst(child.ElementName) #>;
<# } #>

<# } #>
<# } #>
  }

<# } #>
}
<#+

interface IElement
{
    string Name { get; }
}

interface IContainer : IElement
{
    string TypeName { get; }
    string InterfaceName { get; }
    List<IElement> Children { get; }
}

class Section : IContainer
{
    public string Namespace { get; }
    public string Name { get; }
    public string TypeName { get { return Name + "Section"; } }
    public string InterfaceName { get { return "I" + Name; } }
    public bool IsGenerateInterfaces { get; }
    public List<IElement> Children { get; }

    public Section(XElement root)
    {
        Namespace = root.Attribute("namespace").Value;
        Name = root.Attribute("type").Value;
        IsGenerateInterfaces = ParseBool(root, "generateInterfaces", false);
        Children = ParseElements(root);
    }

    public IEnumerable<IContainer> GetAllElements()
    {
        yield return this;

        foreach (var child in Children.OfType<Element>())
        {
            yield return child;

            foreach (var item in child.GetAllElements())
            {
                yield return item;
            }
        }
    }
}

class Element : IContainer
{
    public string Name { get; }
    public string TypeName { get { return Name + "Element"; } }
    public string InterfaceName { get { return "I" + Name + "Configuration"; } }
    public string ElementName { get; }
    public bool IsRequired { get; }
    public bool IsCollection { get; }
    public bool IsDefaultCollection { get; }
    public List<IElement> Children { get; }

    public Element(XElement element)
    {
        Name = element.Attribute("type").Value;
        ElementName = element.Attribute("name").Value;
        IsRequired = ParseBool(element, "required", false);
        IsCollection = element.Name.LocalName == "collection";
        IsDefaultCollection = ParseBool(element, "default", false);
        Children = ParseElements(element);
    }

    public IEnumerable<IContainer> GetAllElements()
    {
        foreach (var child in Children.OfType<Element>())
        {
            yield return child;

            foreach (var item in child.GetAllElements())
            {
                yield return item;
            }
        }
    }

    public string GetKeyPropertyName()
    {
        foreach (var attribute in Children.OfType<Attribute>())
        {
            if (attribute.IsKey)
                return attribute.Name;
        }
        throw new InvalidOperationException();
    }
}

class Attribute : IElement
{
    public string Name { get { return UpperCaseFirst(ElementName); } }
    public string ElementName { get; }
    public string Type { get; }
    public bool IsKey { get; }
    public bool IsRequired { get; }
    public object DefaultValue { get; }

    public Attribute(XElement element)
    {
        ElementName = element.Attribute("name").Value;
        Type = element.Attribute("type").Value;
        IsKey = ParseBool(element, "key", false);
        IsRequired = ParseBool(element, "required", false);
        DefaultValue = element.Attribute("default") == null ? null : element.Attribute("default").Value;
    }
}

static List<IElement> ParseElements(XElement element)
{
    var result = new List<IElement>();

    foreach (var child in element.Elements())
    {
        switch (child.Name.LocalName)
        {
            case "element":
            case "collection":
                result.Add(new Element(child));
                break;
            case "attribute":
                result.Add(new Attribute(child));
                break;
            default:
                throw new InvalidOperationException();
        }
    }

    return result;
}

static string UpperCaseFirst(string value)
{
    return value.Substring(0, 1).ToUpperInvariant() + value.Substring(1);
}

static bool ParseBool(XElement element, string key, bool defaultValue)
{
    if (element.Attribute(key) == null)
        return defaultValue;
    switch (element.Attribute(key).Value)
    {
        case "0":
        case "false":
            return false;
        case "1":
        case "true":
            return true;
        default:
            throw new InvalidOperationException();
    }
}

#>